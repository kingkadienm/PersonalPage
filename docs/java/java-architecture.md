# 架构设计能力

## 设计思想

### 设计模式（常用）

- **工厂**：封装创建；简单工厂、工厂方法、抽象工厂。
- **策略**：算法可替换；同一接口多实现，运行时选择。
- **责任链**：请求沿链传递，某节点处理或传递；过滤器、审批流。
- **模板方法**：父类定义骨架，子类实现步骤；复用流程、扩展点。
- **单例、建造者、观察者、代理、适配器、装饰器**：见 [Java 进阶](/java/java-advanced)。

### SOLID 原则

- **S** 单一职责：类/模块只负责一类变化。
- **O** 开闭：对扩展开放，对修改关闭；抽象与多态。
- **L** 里氏替换：子类可替换父类，不破坏行为。
- **I** 接口隔离：接口细粒度，不强迫实现不用方法。
- **D** 依赖倒置：依赖抽象而非具体；面向接口编程。

### DDD（领域驱动设计）

- 限界上下文、聚合根、实体、值对象、领域服务、仓储；统一语言、按领域划分模块；避免大泥球、贫血模型。

### 分层架构

- 表现层（Controller）、应用层/用例层（Service 编排）、领域层（领域模型与领域服务）、基础设施层（持久化、消息、外部调用）。依赖方向向内；领域层不依赖外层。

## 高并发设计

### 限流

- 计数器、滑动窗口、漏桶、令牌桶；单机 Guava RateLimiter、Redis+Lua；网关/nginx 限流；按 IP、用户、接口维度。

### 熔断

- 失败率/慢调用超阈值则熔断，快速失败或降级；恢复时半开探测。Sentinel、Resilience4j。

### 降级

- 非核心功能关闭或返回默认；保证核心可用。预案：开关、默认值、兜底数据。

### 异步削峰

- 请求进 MQ，消费者按能力处理；前端轮询或 WebSocket 取结果。避免瞬时流量打垮系统。

### 缓存架构

- 多级缓存：本地缓存（Caffeine）+ 分布式缓存（Redis）；缓存更新策略：Cache Aside、Write Through 等；热点 key 分散、防击穿雪崩见 [中间件](/java/java-middleware)。

### 分布式锁

- Redis SET NX EX、Redisson；ZooKeeper 临时顺序节点；数据库唯一约束。选型看一致性要求与性能；注意锁粒度、续期、可重入。

### 分布式事务（Seata）

- AT： undo 日志 + 全局锁，二阶段提交/回滚。TCC：Try-Confirm/Cancel，业务自己实现补偿。SAGA：长事务拆成本地事务 + 补偿。消息最终一致性：本地事务 + 发消息、消费者幂等。

## 微服务治理

### 服务拆分

- 按业务能力、限界上下文；单一职责、高内聚低耦合；避免循环依赖；先粗后细、随业务演进。

### CAP / BASE

- CAP：一致性、可用性、分区容错只能满足其二；通常选 CP 或 AP。BASE：基本可用、软状态、最终一致性；用最终一致替代强一致。

### 灰度发布

- 按比例或按用户标签将流量导到新版本；配合网关、服务发现权重；观察指标后全量。

### 蓝绿部署

- 两套环境，切换流量；回滚即切回。资源双倍。

### 零停机发布

- 滚动发布：分批替换实例；金丝雀先上一部分。配合健康检查、就绪探针；优雅下线（等请求处理完再关）。
